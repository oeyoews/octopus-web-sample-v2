<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èˆ¹åªä½œæˆ˜è¿åŠ¨è½¨è¿¹ - Cesiumå¯è§†åŒ–</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="cesiumContainer" class="w-full m-0 p-0 overflow-hidden h-screen"></div>

    <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-white text-lg z-[1001] font-chinese" id="loadingIndicator">
        æ­£åœ¨åŠ è½½è½¨è¿¹æ•°æ®...
    </div>

    <script>
        // å…¨å±€å˜é‡
        let viewer;
        let trajectoryData = [];
        let shipEntity;
        let trajectoryEntity;
        let pointEntities = [];
        let isPlaying = false;
        let currentIndex = 0;
        let animationSpeed = 1.0;
        let animationId;

        // åˆå§‹åŒ–Cesium
        async function initCesium() {
            // è®¾ç½®Cesiumè®¿é—®ä»¤ç‰Œï¼ˆæ‚¨éœ€è¦æ›¿æ¢ä¸ºæ‚¨è‡ªå·±çš„ä»¤ç‰Œï¼‰
            Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiNjBjYjEzYS02Nzg0LTQ0MWUtYTBkOS1mZjRiYWM1MmJhOTciLCJpZCI6MjY1NTM5LCJpYXQiOjE3NjA1MjAzMTd9.AeBLlQDX2LuRev9h0p8e76atMZVeXRvNev3fGPN3dBI';

            // åˆ›å»ºåœ°å½¢æä¾›è€…
            let terrainProvider;
            try {
                terrainProvider = await Cesium.createWorldTerrainAsync({
                    requestWaterMask: true,
                    requestVertexNormals: true
                });
            } catch (error) {
                console.warn('æ— æ³•åˆ›å»ºä¸–ç•Œåœ°å½¢ï¼Œä½¿ç”¨é»˜è®¤åœ°å½¢:', error);
                terrainProvider = new Cesium.EllipsoidTerrainProvider();
            }

            viewer = new Cesium.Viewer('cesiumContainer', {
                terrainProvider: terrainProvider,
                timeline: false,
                animation: false,
                homeButton: false,
                sceneModePicker: false,
                baseLayerPicker: false,
                navigationHelpButton: false,
                fullscreenButton: false,
                vrButton: false
            });

            // è®¾ç½®åˆå§‹è§†è§’
            viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(130.15, 28.16, 10000),
                orientation: {
                    heading: Cesium.Math.toRadians(0),
                    pitch: Cesium.Math.toRadians(-45),
                    roll: 0.0
                }
            });

            // å¯ç”¨æ·±åº¦æµ‹è¯•
            viewer.scene.globe.depthTestAgainstTerrain = true;
        }

        // åŠ è½½è½¨è¿¹æ•°æ®
        async function loadTrajectoryData() {
            try {
                const response = await fetch('ship_trajectory_data.txt');
                // const response = await fetch('ship_trajectory_segment_4.txt');
                const text = await response.text();

                const lines = text.split('\n');
                trajectoryData = [];

                // è·³è¿‡æ ‡é¢˜è¡Œï¼Œè§£ææ•°æ®
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line) {
                        const parts = line.split('\t');
                        if (parts.length >= 6) {
                            trajectoryData.push({
                                timestamp: parts[0],
                                batchNumber: parseInt(parts[1]),
                                longitude: parseFloat(parts[2]),
                                latitude: parseFloat(parts[3]),
                                depth: parseInt(parts[4]),
                                heading: parseInt(parts[5])
                            });
                        }
                    }
                }

                console.log(`åŠ è½½äº† ${trajectoryData.length} ä¸ªè½¨è¿¹ç‚¹`);
                return trajectoryData;
            } catch (error) {
                console.error('åŠ è½½è½¨è¿¹æ•°æ®å¤±è´¥:', error);
                // å¦‚æœæ— æ³•åŠ è½½æ–‡ä»¶ï¼Œä½¿ç”¨ç¤ºä¾‹æ•°æ®
                // return generateSampleData();
            }
        }

        // åˆ›å»ºèˆ¹åªå®ä½“
        function createShipEntity(position, heading) {
            if (shipEntity) {
                viewer.entities.remove(shipEntity);
            }

            shipEntity = viewer.entities.add({
                position: position,
                model: {
                    uri: 'https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Apps/SampleData/models/CesiumMilkTruck/CesiumMilkTruck.glb',
                    scale: 0.5,
                    minimumPixelSize: 64,
                    maximumScale: 20000
                },
                orientation: Cesium.Transforms.headingPitchRollQuaternion(
                    position,
                    new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(heading), 0, 0)
                ),
                label: {
                    text: 'ğŸš¢ ä½œæˆ˜èˆ¹åª',
                    font: '12pt sans-serif',
                    fillColor: Cesium.Color.WHITE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    pixelOffset: new Cesium.Cartesian2(0, -50),
                    horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                }
            });

            return shipEntity;
        }

        // åˆ›å»ºè½¨è¿¹çº¿
        function createTrajectoryLine() {
            if (trajectoryEntity) {
                viewer.entities.remove(trajectoryEntity);
            }

            const positions = trajectoryData.map(point =>
                Cesium.Cartesian3.fromDegrees(point.longitude, point.latitude, -point.depth)
            );

            trajectoryEntity = viewer.entities.add({
                polyline: {
                    positions: positions,
                    width: 3,
                    material: Cesium.Color.CYAN,
                    clampToGround: false,
                    depthFailMaterial: Cesium.Color.RED
                }
            });

            return trajectoryEntity;
        }

        // åˆ›å»ºè½¨è¿¹ç‚¹
        function createTrajectoryPoints() {
            // æ¸…é™¤ç°æœ‰ç‚¹
            pointEntities.forEach(entity => viewer.entities.remove(entity));
            pointEntities = [];

            // åˆ›å»ºå…³é”®ç‚¹ï¼ˆæ¯10ä¸ªç‚¹æ˜¾ç¤ºä¸€ä¸ªï¼‰
            for (let i = 0; i < trajectoryData.length; i += 10) {
                const point = trajectoryData[i];
                const position = Cesium.Cartesian3.fromDegrees(
                    point.longitude,
                    point.latitude,
                    -point.depth
                );

                const pointEntity = viewer.entities.add({
                    position: position,
                    point: {
                        pixelSize: 8,
                        color: Cesium.Color.YELLOW,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        heightReference: Cesium.HeightReference.NONE
                    },
                    label: {
                        text: `${i + 1}`,
                        font: '10pt sans-serif',
                        fillColor: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 1,
                        pixelOffset: new Cesium.Cartesian2(0, -20),
                        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                    }
                });

                pointEntities.push(pointEntity);
            }
        }

        // æ›´æ–°èˆ¹åªä½ç½®
        function updateShipPosition(index) {
            if (index >= trajectoryData.length) return;

            const point = trajectoryData[index];
            const position = Cesium.Cartesian3.fromDegrees(
                point.longitude,
                point.latitude,
                -point.depth
            );

            // æ›´æ–°èˆ¹åªä½ç½®å’Œæ–¹å‘
            if (shipEntity) {
                shipEntity.position = position;
                shipEntity.orientation = Cesium.Transforms.headingPitchRollQuaternion(
                    position,
                    new Cesium.Transforms.HeadingPitchRoll(Cesium.Math.toRadians(point.heading), 0, 0)
                );
            } else {
                createShipEntity(position, point.heading);
            }
        }

        // ä¸»åˆå§‹åŒ–å‡½æ•°
        async function init() {
            try {
                // åˆå§‹åŒ–Cesiumï¼ˆå¼‚æ­¥ï¼‰
                await initCesium();

                // éšè—åŠ è½½æŒ‡ç¤ºå™¨
                document.getElementById('loadingIndicator').style.display = 'none';

                // åŠ è½½è½¨è¿¹æ•°æ®
                await loadTrajectoryData();

                // åˆ›å»ºå¯è§†åŒ–å…ƒç´ 
                createTrajectoryLine();
                createTrajectoryPoints();

                // è®¾ç½®åˆå§‹èˆ¹åªä½ç½®
                updateShipPosition(0);

                console.log('èˆ¹åªè½¨è¿¹å¯è§†åŒ–åˆå§‹åŒ–å®Œæˆ');

            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                document.getElementById('loadingIndicator').textContent = 'åˆå§‹åŒ–å¤±è´¥: ' + error.message;
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', init);
    </script>
</body>
</html>
